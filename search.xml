<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring相关小结</title>
      <link href="/2019/07/26/Spring%E7%9B%B8%E5%85%B3%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/07/26/Spring%E7%9B%B8%E5%85%B3%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="Spring相关小结"><a href="#Spring相关小结" class="headerlink" title="Spring相关小结"></a>Spring相关小结</h4><p>Spring是一个相对轻量级的Java开发框架，用于简化Java程序的开发，其特点：</p><ul><li>基于POJO轻量级和最小侵入式开发</li><li>通过依赖注入和面向接口实现松耦合 （IOC/DI）</li><li>基于切面和惯例进行声明式编程（AOP）</li></ul><p><img src="https://i.loli.net/2019/07/26/5d39d5e697e9831418.jpg" alt="Spring框架图.jpg"></p><p><strong>如图，<em>为Spring框架图</em></strong></p><p>由于Spring框架中涉及到很多Java设计模式的东西，推荐阅读《Java编程思想》。这里主要介绍Spring的一些特点和用法。</p><h5 id="Spring-Ioc和AOP"><a href="#Spring-Ioc和AOP" class="headerlink" title="Spring Ioc和AOP"></a>Spring Ioc和AOP</h5><ul><li><p><em>Ioc为控制反转将原本在程序中手动创建对象的控制权，交由Spring框架来管理，</em> IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p></li><li><p>控制反转其实是一种设计模式，可以使用手动的方式来达到目的（只是需要手动new 一堆类），而Spring提供了Ioc容器 ， 将本来自己手动new的那一堆类通过你之前写的配置文件（xml/注解）放入Ioc容器中，来达到“开箱即用的效果”），其次Ioc再有一个好处就是我们在创建实例的时候不需要了解其中的细节</p></li><li><p>AOP为面向切面编程将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</p></li><li>其实我们也可以使用动态代理来实现面向切面编程（此处主要涉及到设计模式）</li></ul><h5 id="关于Spring中的Bean"><a href="#关于Spring中的Bean" class="headerlink" title="关于Spring中的Bean"></a>关于Spring中的Bean</h5><ul><li>Bean来自于Spring的Ioc特性，其实Bean就是Spring反转控制后的产物，即可以把Bean理解为对象（ 被反转控制的对象的）的代理人，它拥有该对象的全部属性方法</li></ul><h5 id="SpringIoc方面的注解"><a href="#SpringIoc方面的注解" class="headerlink" title="SpringIoc方面的注解"></a>SpringIoc方面的注解</h5><p>SpringIoc方面的注解可分为两类：</p><ul><li>一类是注册Bean，将类转换化为一个Bean放入Ioc容器中，例如@Component , @Repository , @ Controller , @Service , @Configration</li><li>一类是使用Bean，完成属性和方法的组装，例如@Autowired , @Resource</li></ul><p>关于@Component和@Bean的区别：</p><ul><li>首先上文已提到，@Component和@Bean都是在注册Bean， 但这两个注解的作用 对象不同，@Component作用于类上而@Bean作用域方法上</li><li>@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现（暂时还没有找到比较清晰的实例）</li></ul><h5 id="Spring的事务管理"><a href="#Spring的事务管理" class="headerlink" title="Spring的事务管理"></a>Spring的事务管理</h5><p>主要是使用声明式事务（基于XML和基于注解的）</p><p>其实传统使用Spring的姿势是使用XML的方式去进行配置Bean的，但是随着SpringBoot的流行，官方都跟推荐零配置（XML）的解决方案，所以我们更喜欢使用SpringBoot，使用注解的方式来完成配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础 - 集合</title>
      <link href="/2019/07/10/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
      <url>/2019/07/10/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h5 id="由于最近需要准备面试，来复习一下Java中的几种常见的集合类"><a href="#由于最近需要准备面试，来复习一下Java中的几种常见的集合类" class="headerlink" title="由于最近需要准备面试，来复习一下Java中的几种常见的集合类"></a>由于最近需要准备面试，来复习一下Java中的几种常见的集合类</h5><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>可以说是平常使用最多的一个类了，它里面可以存放任意内容，基本没有什么限制，齐下有两种存储结构类：</p><ul><li><strong>ArrayList</strong></li><li><strong>LinkedList</strong></li></ul><p>其具体区别如下：</p><ul><li><p><strong><em>ArrayList的底层实现是使用了Object数组的方式</em>，由于底层的实现是使用了数组，所以可以做到顺序存放随即存取（插入和删除的时间复杂度会受到位置的影响）</strong></p></li><li><p><strong><em>LinkedList的底层实现是使用链式存储（双向链表，jdk1.6之前使用的是双向循环链表）</em>，所以可以做到随机存放，顺序存取（插入和删除的时间复杂度不会受到位置的影响）</strong></p></li><li><p><strong>在遍历List的时候可使用for和 iterator（<em>foreach为 iterator的语法糖</em>）</strong></p></li></ul><p>ps:Vector与ArrayList相比，Vector是线程安全的，做了同步机制，但是单线程的情况下使用Vector会在同步上产生额外开销，而且ArrayList和LinkedList都没有做同步机制，所以不是线程安全的</p><h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><p>它不允许存放相同的对象，即不能重复，而且Set不是线程安全的<br>Set的底层使用的是Map的结构实现的，若要实现Set的线程安全，可以使用ConcurrentHashMap的方式使其线程安全</p><h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><p>它以键值对的形式存放（Web中常用于自定义Json接受体），关于Map集合中比较关心的是</p><ul><li><strong>HashMap</strong></li><li><strong>HashTable</strong></li><li><strong>ConcurrentMap</strong></li></ul><p>其具体区别如下：</p><ul><li><p><strong><em>HashMap的底层实现是使用散列表存储</em>（哈希表）（其内部的存储机制为数组+链表（***</strong>若链表长度达到阈值后则转化为红黑树<strong>*</strong>））在HashMap中允许null作为键（只有一个），可以有一个或者多个键所对应的值为null。HashMap的默认值大小为16，其按照2的幂次方进行扩充。线程安全性方面：HashMap不是线程安全的**</p></li><li><p><strong><em>HashTable的底层实现就只是使用散列表存储</em>（数组+链表），在扩容方面若HashTable未指定大小，初始化默认值为11，按照2n+1的方式进行扩充。HashTable 中只要put进去null会抛出NullPointerException，所以其中不能为空。<br>在线程安全性方面，HashTable内部的方法基本上都被synchroized修饰过（如果要绝对的线程安全，请使用ConcurrentHashMap）</strong></p></li><li><p><strong><em>ConcurrentHashMap的底层使用与HashMap一样的数据结构</em>（数组+链表/红黑二叉树），其只是在线程安全方面对并发做了优化其底层使用数据段（segment）的分割方式进行分段加锁（JDK1.8后直接用 Node 数组+链表+红黑树的数据结 构来实现，并发控制使用 synchronized 和 CAS 来操作）（死锁 + 活锁）</strong></p></li></ul><p>并发控制如图所示：<br>（图片来源：<a href="http://www.cnblogs.com/chengxiao/p/6842045.html5）" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html5）</a><br><img src="https://i.loli.net/2019/07/25/5d392d990318b62816.jpg" alt="HashTable加锁方式.jpg"><br><img src="https://i.loli.net/2019/07/25/5d392d992138847785.jpg" alt="JDK1.7的ConcurrentMap加锁方式.jpg"><br><img src="https://i.loli.net/2019/07/25/5d392d9932c7149882.jpg" alt="JDK1.8的ConcurrentMap的加锁方式.jpg"><br>ps：传统的HashTable是使用了synchroized全表加锁的方式，而ConcurrentHashMap使用的是segment分段加锁的方式，JDK1.8中ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）</p><p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。 </p><h6 id="HashMap与HashSet"><a href="#HashMap与HashSet" class="headerlink" title="HashMap与HashSet"></a>HashMap与HashSet</h6><p>可以说HashSet基本是调用HashMap，只不过实现了Set接口  ，使用成员对象来计算hashCode。<br>关于HashSet的重复检查，当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，若发现有相同的hashCode，HashSet会调用equals()方法来检查hashCode是否真的相同。</p><h5 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h5><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security基础入门小结</title>
      <link href="/2019/06/20/Spring-Security%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/06/20/Spring-Security%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Security基础入门小结"><a href="#Spring-Security基础入门小结" class="headerlink" title="Spring Security基础入门小结"></a>Spring Security基础入门小结</h2><p>由于最近在做Vue+SpringBoot的后台管理项目的登录模块，该模块相对于传统登录方式（Session）有着很大的不同，所以使用了Spring Security来辅助进行token方式的验证登录。</p><blockquote><p>参考与推荐： <a href="https://juejin.im/post/5caf0677e51d456e7d189f44" target="_blank" rel="noopener">SpringBoot个人应用开发框架 - 使用Spring Security管理访问权限</a>、<a href="https://blog.csdn.net/abcwanglinyong/article/details/80981389" target="_blank" rel="noopener">Spring-Security登录认证授权原理</a></p></blockquote><h3 id="为什么需要Spring-Security"><a href="#为什么需要Spring-Security" class="headerlink" title="为什么需要Spring Security"></a>为什么需要Spring Security</h3><p>现如今的框架技术是越来越多，所以怎么选择成为一个很重要的问题。在技术选型之前，一定要搞清楚我们为什么需要这项技术，理清思路很是关键。</p><p>首先Spring Security是什么？我们为什么需要使用Spring Security? </p><p><strong><em>Spring</em> Security is a Java/Java EE framework that provides authentication, authorization and other security features for enterprise applications.</strong></p><p>以上是维基百科中对Spring Security的解释，它的主要功能是对应用进行授权和认证，这也正是我们所需要使用的功能。</p><p>在传统的登录方式中（Session）我们的流程通常是：</p><ul><li>用户通过前端的文本框输入用户名和密码（需要后台认证的信息）</li><li>后端获取到来自前端的用户名和密码，处理用户名和密码</li><li>后端的处理方法可以有很多，最简单的就是按用户名（用户唯一标识）去数据库取出用户密码，与来自前端的密码做比较</li></ul><p>上述传统的登录方式一般用于MVC（模板渲染）的设计模式，但是在现在前后端分离开发、分离部署的热潮下，加之分布式微服务的热度不断高涨，传统的Session验证登录的方式就会暴露出很多的问题。这使得基于Token的验证方式受到大多数人的青睐。</p><p>说到这里先来了解一下Token：</p><p>Token说白了就是一个字符串，它由三部分组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。我们就把它当作一个字符产使用即可。</p><p>下面再来简单的了解一些Token的验证流程：</p><p>由于HTTP是一种无状态的协议，它不知道是谁访问了我们的应用，是否通过权限验证。传统的验证方式是使用Cookie+Session的方式，但是这种方式后端的服务器需要保存每个用户的SessionId，在用户访问量大的情况下，这是一笔不小的开销。</p><p>token的验证机制是，前端传过来用户名和密码，后端验证成功（密码一致）后，后端会生成一个token，然后把该token发送给前端，前端收到后会把该token存储起来，在之后请求后端资源的过程中，前端只需要带着那个token向后端请求，后端收到请求后先去验证该token的合法性，合法即返回请求的资源。</p><p><img src="http://wx2.sinaimg.cn/mw690/006Dr5U1ly1g4sc8mwqx7j30hr0ejt92.jpg" alt="token验证流程"></p><p>在这个流程中主要起到作用的是后端验证Token的过滤器，而Spring Security中会有大量的过滤器（过滤器链），这也是我们使用Spring Security的一个原因。</p><h3 id="Spring-Security的验证流程"><a href="#Spring-Security的验证流程" class="headerlink" title="Spring Security的验证流程"></a>Spring Security的验证流程</h3><p>Spring Security的登录验证流程图：</p><p><img src="http://wx2.sinaimg.cn/mw690/006Dr5U1ly1g4scbu72w1j30ub0kbgos.jpg" alt="Spring Security的登录验证流程图"></p><p>根据上图可以看出，在Spring Security的验证流程基本涉及到这么几个模块：</p><ul><li>SecurityContextPersistenceFilter</li><li>AuthenticationManager</li><li>DaoAuthenticationProvider</li><li>UserDetailsService</li><li>UserDetails</li></ul><p>对应到Token验证登录的项目中来，即：</p><ul><li>首先自定义一个过滤器来拦截前端请求中的Token</li><li>自定义过滤器内业务执行完成后将仍证信息保存至SecurityContextHolder</li><li>重写用户详细权限类（继承UserDetails）</li><li>重写UserDetailsService(继承UserDetailsService)</li></ul><hr><h3 id="SpringBoot整合Spring-Security的类Restful风格API后台程序框架搭建"><a href="#SpringBoot整合Spring-Security的类Restful风格API后台程序框架搭建" class="headerlink" title="SpringBoot整合Spring Security的类Restful风格API后台程序框架搭建"></a>SpringBoot整合Spring Security的类Restful风格API后台程序框架搭建</h3><h4 id="框架搭建准备工作"><a href="#框架搭建准备工作" class="headerlink" title="框架搭建准备工作"></a>框架搭建准备工作</h4><p>首先将所需依赖引入项目（我这里使用的是Maven）<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.9.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>项目目录结构如下：</p><p><img src="http://wx3.sinaimg.cn/mw690/006Dr5U1ly1g4sc8nd9o4j30dh0isjro.jpg" alt="项目目录结构"></p><h5 id="完成Spring-Security配置项"><a href="#完成Spring-Security配置项" class="headerlink" title="完成Spring Security配置项"></a>完成Spring Security配置项</h5><p>在Spring Security中对于整个框架的配置实现基本上都来自于WebSecurityConfigurerAdapter类，所以我们也只需要继承它，重写其中的配置方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class SecurityConfigurer extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line">    </span><br><span class="line">    //构造函数注入法</span><br><span class="line">    @Autowired</span><br><span class="line">    public SecurityConfigurer(UserDetailsService userDetailsService, JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter)&#123;</span><br><span class="line">        this.userDetailsService = userDetailsService;</span><br><span class="line">        this.jwtAuthenticationTokenFilter = jwtAuthenticationTokenFilter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    *   此处需要手动注入</span><br><span class="line">    *   否则会报：</span><br><span class="line">    *   Field authenticate in com.ywh.security.service.impl.SysUserServiceImpl required a bean of type</span><br><span class="line">    *   &apos;org.springframework.security.authentication.AuthenticationManager&apos; that could not be found.</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void configure(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        httpSecurity</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                // 开始认证</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                // 对静态文件和登陆页面放行</span><br><span class="line">                .antMatchers(&quot;/user/**&quot;).permitAll()</span><br><span class="line">                // 其他请求需要认证登陆(注意：其他拦截路径要放到最后，放在前面会出现都被拦截的情况)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 注入自定义的 jwt过滤器,添加在UsernamePasswordAuthenticationFilter过滤器之前</span><br><span class="line">        httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        // 这块是配置跨域请求的</span><br><span class="line">        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry registry = httpSecurity.authorizeRequests();</span><br><span class="line">        // 让Spring security放行所有preflight request</span><br><span class="line">        registry.requestMatchers(CorsUtils::isPreFlightRequest).permitAll();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要关注两个地方：</p><ul><li>AuthenticationManager必须手动注册为Bean，否则会报找不到异常</li><li>重写configure()方法时注意禁用csrf（跨域请求）否则无法提交，authorizeRequests方面注意放行的接口（如登录接口）</li></ul><p>其次我们将跨域请求的过滤器也放置到这里进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        final UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        final CorsConfiguration cors = new CorsConfiguration();</span><br><span class="line">        cors.setAllowCredentials(true);</span><br><span class="line">        cors.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">        cors.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">        cors.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, cors);</span><br><span class="line">        return new CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>还有在配置文件中可以设置密码的加密方式，这里可以根据自己的业务需求自己选用合适的加密方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此以上就完成了Spring Security的基本配置</p><h4 id="准备Token工具"><a href="#准备Token工具" class="headerlink" title="准备Token工具"></a>准备Token工具</h4><p>关于解析和生成Token的工具有非常多这里推荐两个（我使用的是jjwt）</p><ul><li><a href="https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt" target="_blank" rel="noopener">jjwt</a></li><li><a href="https://mvnrepository.com/artifact/com.auth0/java-jwt" target="_blank" rel="noopener">Java JWT</a></li></ul><p>完成Token工具，编写JwtTokenUtil类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassName JwtTokenUtil</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author JOKER</span><br><span class="line"> * @Date: 2019/6/2 15:47</span><br><span class="line"> * @Version</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;jwt&quot;)</span><br><span class="line"></span><br><span class="line">public class JwtTokenUtil &#123;</span><br><span class="line"></span><br><span class="line">    private String secret;</span><br><span class="line"></span><br><span class="line">    private Long expiration;</span><br><span class="line"></span><br><span class="line">    private String header;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从数据声明生成令牌</span><br><span class="line">     *</span><br><span class="line">     * @param claims 数据声明</span><br><span class="line">     * @return 令牌</span><br><span class="line">     */</span><br><span class="line">    private String generateToken(Map&lt;String, Object&gt; claims) &#123;</span><br><span class="line">        Date expirationDate = new Date(System.currentTimeMillis() + expiration);</span><br><span class="line">        return Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(expirationDate)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从令牌中获取数据声明</span><br><span class="line">     *</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return 数据声明</span><br><span class="line">     */</span><br><span class="line">    private Claims getClaimsFromToken(String token) &#123;</span><br><span class="line">        Claims claims;</span><br><span class="line">        try &#123;</span><br><span class="line">            claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            claims = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成令牌</span><br><span class="line">     * @return 令牌</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(String userName) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(2);</span><br><span class="line">        claims.put(&quot;sub&quot;, userName);</span><br><span class="line">        claims.put(&quot;created&quot;, new Date());</span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从令牌中获取用户名</span><br><span class="line">     *</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return 用户名</span><br><span class="line">     */</span><br><span class="line">    public String getUsernameFromToken(String token) &#123;</span><br><span class="line">        String username;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            username = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断令牌是否过期</span><br><span class="line">     *</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return 是否过期</span><br><span class="line">     */</span><br><span class="line">    public Boolean isTokenExpired(String token) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            Date expiration = claims.getExpiration();</span><br><span class="line">            return expiration.before(new Date());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;该令牌过期&quot;);</span><br><span class="line">            throw null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新令牌</span><br><span class="line">     *</span><br><span class="line">     * @param token 原令牌</span><br><span class="line">     * @return 新令牌</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String token) &#123;</span><br><span class="line">        String refreshedToken;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            claims.put(&quot;created&quot;, new Date());</span><br><span class="line">            refreshedToken = generateToken(claims);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            refreshedToken = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return refreshedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证令牌</span><br><span class="line">     *</span><br><span class="line">     * @param token       令牌</span><br><span class="line">     * @param userDetails 用户</span><br><span class="line">     * @return 是否有效</span><br><span class="line">     */</span><br><span class="line">    public Boolean validateToken(String token, UserDetails userDetails) &#123;</span><br><span class="line">        SecurityUserDetails user = (SecurityUserDetails) userDetails;</span><br><span class="line">        String username = getUsernameFromToken(token);</span><br><span class="line">        return (username.equals(user.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是需要配置一下首次的jwt加密字符，相当于配置三个常量，在每次加载的时候可以不用手动在写</p><p>在SpringBoot的配置文件.yml（默认为.properties）中配置以下常量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jwt:</span><br><span class="line">  header: x-auth-token      #头名称，注意与前端request发送的头名称要相同</span><br><span class="line">  secret: eyJleHAiOjE1NDMyMDUyODUsInN1YiI6ImFkbWluIiwiY3Jl</span><br><span class="line">  expiration: 3600000       #超时时间</span><br></pre></td></tr></table></figure></p><p>现在我们有了Token工具，可以生成和解析Token了</p><h4 id="创建登录功能的相关实体"><a href="#创建登录功能的相关实体" class="headerlink" title="创建登录功能的相关实体"></a>创建登录功能的相关实体</h4><p>这里首先我们应该先了解一下关于权限设计的数据库表设计</p><p>详细的权限表结构设计请参考：<a href="https://blog.csdn.net/painsonline/article/details/7183613/" target="_blank" rel="noopener">RBAC权限管理</a></p><p>这里我们根据自己的业务做了相应的简化，表结构如下：<br><img src="https://i.loli.net/2019/07/23/5d36ce5284fe862893.jpg" alt="权限设计数据库表结构.jpg"></p><p>有了数据库的表结构，我们就可以根据表结构来创建实体类了（JavaBean那一套）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userpass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Roles&gt; roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Roles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String roleid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rolename;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里需要注意，由于我们使用Spring Security来进行登录方面的安全验证，可以使用Spring Security的UserDetails为我们提供的可扩展用户信息接口，保存一些非敏感类的信息</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityUserDetails</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;? extends GrantedAuthority&gt; authorties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityUserDetails</span><span class="params">(String username,String password,Integer state,Collection&lt;? extends GrantedAuthority&gt; authorties)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.authorties = authorties;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="UserDetailsService接口"><a href="#UserDetailsService接口" class="headerlink" title="UserDetailsService接口"></a>UserDetailsService接口</h4><p>在登录模块中最关键的一步就是用来自前端的用户名和密码与数据库中的用户名和密码做比对，若成功即登录成功</p><p>所以我们需使用Spring Security提供的UserDetailsService接口来重写其中的loadUserByUsername()方法，然后将查询出来的用户详细信息放到UserDetails实现的自类中（我们这里是SecurityUserDetails）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityUserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DaoUser daoUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityUserDetailsServiceImpl</span><span class="params">(DaoUser daoUser)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.daoUser = daoUser;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        User user = daoUser.selectByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            List&lt;SimpleGrantedAuthority&gt; collect = user.getRoles().stream().map(Roles::getRolename)</span><br><span class="line">                    .map(SimpleGrantedAuthority::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SecurityUserDetails(user.getUsername(),user.getUserpass(),user.getState(),collect);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"该用户不存在"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，在向数据库查询后，使用了JDK1.8的一个新的流的功能（stream），这里我理解的还不够清晰，故以后会在详细记录流操作的用法（推荐阅读：<a href="https://blog.csdn.net/Keith003/article/details/80252553" target="_blank" rel="noopener">jdk1.8新特性 Stream API</a>）、<a href="https://www.jianshu.com/p/d6b45c550782?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">jdk1.8新特性之Stream使用详解</a><br>）</p><p>总之通过loadUserByUsername()方法我们通过用户名拿到了用户的详细信息</p><p>至此我们就已经基本完成了基于JWT+Spring Security的验证，现在我们编写相关的登录Controller来验证我们的程序</p><h4 id="编写登录Controller"><a href="#编写登录Controller" class="headerlink" title="编写登录Controller"></a>编写登录Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountLogin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(AccountLogin.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@RequestBody Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String token = userService.login(map.get(<span class="string">"username"</span>),map.get(<span class="string">"password"</span>));</span><br><span class="line">            <span class="keyword">return</span> Result.successJson(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"登录失败"</span>,e);</span><br><span class="line">            <span class="keyword">return</span> Result.errorJson(ResultCode.PASSWORD_ERROR.getMsg(),ResultCode.PASSWORD_ERROR.getIndex());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"userInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">userInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Object authentication = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="keyword">if</span>(authentication <span class="keyword">instanceof</span> SecurityUserDetails)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.successJson(userService.findUserInfo(((SecurityUserDetails) authentication).getUsername()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.errorJson(ResultCode.LOGIN_AGIN.getMsg(),ResultCode.LOGIN_AGIN.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"logout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">logout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.successJson(<span class="string">"退出成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里login()使用post方式接受来自前端的用户名和密码，使用map的方式自定义接受json的方式，最后我们可以使用postman这个工具来测试这个Controller接口（关于postman的使用这里就不做介绍了，非常简单）</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此我们就完成了使用Spring Security +<br>JWT的基于Token的登录验证方式。这里我们再来回顾一下这个过程中的几个重要的点：</p><ul><li>首先搞清楚我们为什么需要使用Token、传统的Session有什么问题、为什么需要Spring Security来验证</li><li>Spring Security的验证流程（可以结合我上面给的验证流程图加IDEA的调试环境单步调试一下，来体会验证的过程）</li><li>注意Spring Security的配置类，主要关注WebSecurityConfigurerAdapter，都是继承它来的</li><li>注意继承UserDetailsService来重写loadUserByUsername()方法</li></ul><p><strong>ps：（注意Spring Security 5.0+的版本强制要求密码加密，不能直接明文，当时这个错我搞了我好几天）</strong></p><p>上述Demo我已上传至Github，需要详细了解的同学可自行clone</p><p><a href="https://github.com/SMLYSR/Jwt-Spring-Security" target="_blank" rel="noopener">结合使用Jwt与Spring Security完成前后端分离的类Restful风格接口</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简洁直白图解“三次握手，四次挥手”</title>
      <link href="/2019/05/20/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/05/20/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简洁直白图解TCP“三次握手和四次挥手”"><a href="#简洁直白图解TCP“三次握手和四次挥手”" class="headerlink" title="简洁直白图解TCP“三次握手和四次挥手”"></a>简洁直白图解TCP“三次握手和四次挥手”</h2><blockquote><p>参考学习<a href="https://juejin.im/post/5b29d2c4e51d4558b80b1d8c#comment" target="_blank" rel="noopener">：跟着动画来学习TCP三次握手和四次挥手</a>、<a href="https://juejin.im/post/5ad4094e6fb9a028d7011069" target="_blank" rel="noopener">小哥哥，小姐姐，我有一份tcp、http面试指南你要吗？</a></p></blockquote><p>一提起TCP/IP协议，基本大家伙都会说TCP啊，“三次握手，四次挥手”嘛。距离上次看计算机网络书已经过去较长的时间了，这次我们就来重新认识一下TCP的“三次握手和四次挥手”。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>在现实的应用场景中会有各种各样的端设备，这里我们就暂时将其分为客户端和服务端。</p><p>下图为TCP通信中客户端与服务端的连接示意图：<br><img src="http://wx1.sinaimg.cn/mw690/006Dr5U1ly1g4slhyo4dcj30hg0iw0sx.jpg" alt="TCP三次握手"></p><p>TCP的三次握手是客户端与服务器建立连接之前的准备工作，客户端在前请求服务端资源前首先需要建立TCP连接，具体流程为：</p><ul><li>首先资源申请方（客户端）在建立TCP前会进入syn_sent状态（syn package has been sent）</li><li>之后客户端会向服务端发送syn标识（syn=1）随机产生seq number的数据包到服务器，使服务端知晓客户端要与其进行TCP连接</li><li>目标资源方（服务端）在接收到来自客户端的syn标识后，服务端会进入syn_rcvd状态</li><li>进入syn_rcvd状态的服务端随即向客户端发送ack+syn（ack=seq+1），即表示已收到服务端的连接请求（其实这里是两步合成一步来执行了syn+ack）</li><li>客户端在收到来自服务端的应答标识后（ack）,客户端随即进入established状态，随后发出客户端的ack标识，来通知以收到服务端的ack+syn</li><li>服务端再次收到来自客户端的ack标识后，表明客户端已经入established状态，随即自己也进入established状态</li></ul><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>四次挥手是客户端和服务器在断开连接前的准备工作，具体流程为：<br><img src="https://i.loli.net/2019/07/22/5d35940c1b0ac66605.jpg" alt="TCP-四次挥手.jpg"></p><ul><li>首先客户端会进入一个停止等待状态，并且会想服务器发送fin1报文</li><li>服务端在收到fin1报文后混进入close_wait状态，并向客户端发送ack应答报文表示已收到，使客户端随即进入fin_wait_2</li><li>上述过程后客户端以向服务器发完断开连接的报文(客户端已经表示我说完了，此时属于半关闭状态，这时服务器还是可以向客户端发送信息的)</li><li>随后客户端会向客户端发送fin2报文（此过程为服务器向客户端发送断开连接的报文）</li><li>客户端在收到fin2后会返回应答ack报文，随即进入time_wait（这是一个特殊的状态，是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的）</li><li>服务端在收到来自客户端的ack应答报文后随即关闭，之后的客户端会在达到time_wait的阈值时间后断开连接，释放资源</li></ul><p>关于TCP的相关问题还是比较复杂的，本文只是用最简单直白的方法描述了TCP/IP的“三次握手和四次挥手”，关于深层次的TCP问题推荐阅读《TCP/IP详解 卷1：协议》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入门语法</title>
      <link href="/2019/04/12/JavaScript%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/04/12/JavaScript%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript-语法入门"><a href="#Javascript-语法入门" class="headerlink" title="Javascript 语法入门"></a>Javascript 语法入门</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。<br>（和Python一样，JS也是一种解释型的脚本语言）    </p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>JS是一种弱类型的语言（这一点与PHP、Python相同）</p><p><code>var a = 1</code></p><p>注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。</p><p>如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。</p><p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。</p><p>关于变量名的命名方式，JS与其他语言没什么区别</p><p><code>1a  // 第一个字符不能是数字</code></p><p><code>***  // 标识符不能包含星号</code></p><p><code>a+b  // 标识符不能包含加号</code></p><p>以上均是不合法的命名（注意：在JS中，中文是合法的标识符）</p><p><code>var 这是一个变量 = 1</code></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><pre><code>在JS中提供了三种注释的方法：`` // 这是一行注释 ````/**/ 多行注释````&lt;!----&gt;继承了HTML的注释方式``（注意：需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。）</code></pre><h4 id="if-else-amp-amp-for-循环"><a href="#if-else-amp-amp-for-循环" class="headerlink" title="if else &amp;&amp; for 循环"></a>if else &amp;&amp; for 循环</h4><pre><code>任何程序都逃脱不了if else &amp;&amp; for 循环，JS中的循环判断与其他语言没有什么差别注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。</code></pre><h4 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h4><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下</p><p>标签可以是任意的标识符，但不能是保留字（标签通常与break、continue配合使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">top: </span><br><span class="line"> for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">   for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">     if (i === 1 &amp;&amp; j === 1) continue top;</span><br><span class="line">     console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code>上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>JavaScript 语言的每一个值，都属于某一种数据类型。这也就是弱类型语言在赋值时可判断变量的数据类型的原因。</p><p>在基础的JS语言中将会涉及到六种数据类型（ES6中有新添加了一种）</p><ul><li>数值（number）：整数和小数（比如1和3.14）</li><li>字符串（string）：文本（比如Hello World）。</li><li>布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）</li><li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li><li>null：表示空值，即此处的值为空。</li><li><p>对象（object）：各种值组成的集合。</p><p>  其中，对象（object）右可分为：狭义对象、数组、函数（函数可以返回数据，所以在JS中被称为对象）</p></li></ul><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>JavaScript 有三种方法，可以确定一个值到底是什么类型</p><ul><li>typeof运算符</li><li>instanceof运算符</li><li>Object.prototype.toString方法</li></ul><p>typeof运算符可以返回一个值的数据类型。</p><p>数值、字符串、布尔值分别返回number、string、boolean，函数返回funcation，undefined返回undefined，<br>对象返回Object</p><p>在实际的编程中可用其进行条件判断，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof v === &quot;undefined&quot;) &#123;</span><br><span class="line"> // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####关于null与undefine的几点说明</p><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，<br>在实际的编程使用的过程中效果几乎没区别。</p><p>要是非要说个一二三，那便要谈及历史问题：</p><pre><code>在第一版的JavaScript中将null规定为Object类型，表示“无&quot;(与C语言中类似，C语言中也根据编译环境来区分)null可转换为数字0，而undefined在转为数值类型时将是NaN</code></pre><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。<br>所以，1与1.0是相同的，是同一个数。</p><p>所以在使用的时候，小心精度问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">0.3 / 0.1</span><br><span class="line">// 2.9999999999999996</span><br><span class="line"></span><br><span class="line">(0.3 - 0.2) === (0.2 - 0.1)</span><br><span class="line">// false</span><br></pre></td></tr></table></figure></p><p>需要注意几点：</p><ol><li><strong><em>NaN</em></strong>是 JavaScript 的特殊值，表示“非数字”（Not a Number），<br>主要出现在将字符串解析成数字出错的场合。</li><li><strong><em>Infinity</em></strong>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，<br>或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。</li></ol><h4 id="几种与数值相关的方法"><a href="#几种与数值相关的方法" class="headerlink" title="几种与数值相关的方法"></a>几种与数值相关的方法</h4><ul><li><p>parseInt()</p><p> parseInt方法用于将字符串转为整数。</p></li><li><p>parseFloat() </p><p>parseFloat方法用于将一个字符串转为浮点数。</p></li><li><p>isNaN()</p><p>isNaN方法可以用来判断一个值是否为NaN。</p></li><li><p>isFinite()<br>isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>用单引号或双引号包裹起来的多个字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;</span><br><span class="line">&quot;abc&quot;</span><br><span class="line">//(推荐使用单引号)</span><br></pre></td></tr></table></figure></p><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p><p>但是如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，<br>用来转义。双引号字符串内部使用双引号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;Did she say \&apos;Hello\&apos;?&apos;</span><br><span class="line">// &quot;Did she say &apos;Hello&apos;?&quot;</span><br><span class="line"></span><br><span class="line">&quot;Did she say \&quot;Hello\&quot;?&quot;</span><br><span class="line">// &quot;Did she say &quot;Hello&quot;?&quot;</span><br></pre></td></tr></table></figure></p><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line">s[1] // &quot;e&quot;</span><br><span class="line">s[4] // &quot;o&quot;</span><br><span class="line"></span><br><span class="line">// 直接对字符串使用方括号运算符</span><br><span class="line">&apos;hello&apos;[1] // &quot;e&quot;</span><br></pre></td></tr></table></figure></p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> foo: &apos;Hello&apos;,</span><br><span class="line"> bar: &apos;World&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，<br>通常把这个属性称为“方法”，它可以像函数那样调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> p: function (x) &#123;</span><br><span class="line">   return 2 * x;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(1) // 2</span><br></pre></td></tr></table></figure><p><strong><em>特别说明：</em></strong></p><p>在JavaScript中对象采用大括号来表示，这导致了一个问题：如果行首是一个大括号，<br>它到底是表达式还是语句？</p><p><code>{ foo: 123 }</code></p><p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，<br>无法确定是对象还是代码块，一律解释为代码块。</p><p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，<br>只能是表达式，所以确保大括号只能解释为对象。</p><p><code>({ foo: 123 })</code></p><h4 id="关于对象的操作"><a href="#关于对象的操作" class="headerlink" title="关于对象的操作"></a>关于对象的操作</h4><p>在JavaScript中操作对象的方法有两种：一种是使用点运算符，还有一种是使用方括号运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> p: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p // &quot;Hello World&quot;</span><br><span class="line">obj[&apos;p&apos;] // &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p><p>不过一般都使用点运算符</p><p>利用for…in 循环进行属性的遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line"></span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line"> console.log(&apos;键名：&apos;, i);</span><br><span class="line"> console.log(&apos;键值：&apos;, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 键名： a</span><br><span class="line">// 键值： 1</span><br><span class="line">// 键名： b</span><br><span class="line">// 键值： 2</span><br><span class="line">// 键名： c</span><br><span class="line">// 键值： 3</span><br></pre></td></tr></table></figure></p><p>for…in循环有两个使用注意点:</p><p>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。<br>它不仅遍历对象自身的属性，还遍历继承的属性。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在JavaScript中一般使用三种方法来构造函数：</p><ol><li><p>function 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function print(s) &#123;</span><br><span class="line"> console.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var print = function(s) &#123;</span><br><span class="line"> console.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Function 构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = new Function(</span><br><span class="line"> &apos;x&apos;,</span><br><span class="line"> &apos;y&apos;,</span><br><span class="line"> &apos;return x + y&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line"> return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p>与其他编程语言相同。JavaScript（ES5）的函数作用域有两种：</p><p>一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；<br>另一种是函数作用域，变量只在函数内部存在。</p><p>在JavaScript中有一个较为重要的概念为闭包，这里先不去介绍，后续会专题讲解。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br></pre></td></tr></table></figure></p><p>其实在JavaScript中将数字当作对象处理，我们可以使用typeof来观察类型</p><h4 id="特别说明-与-运算符"><a href="#特别说明-与-运算符" class="headerlink" title="特别说明 == 与 === 运算符"></a>特别说明 == 与 === 运算符</h4><p>简单说，它们的区别是相等运算符（==）比较两个值是否相等，<br>严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，<br>严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，<br>再用严格相等运算符进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 === &quot;1&quot; // false</span><br><span class="line">true === &quot;true&quot; // false</span><br><span class="line">1 === 0x1 // true</span><br></pre></td></tr></table></figure></p><h4 id="void运算符"><a href="#void运算符" class="headerlink" title="void运算符"></a>void运算符</h4><p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: void(document.form.submit())&quot;&gt;</span><br><span class="line"> 提交</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>当用户点击提交按钮后，页面并不会跳转。</p><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><ol><li><strong><em>Number()</em></strong></li></ol><p>使用Number函数，可以将任意类型的值转化成数值。</p><ol start="2"><li><strong><em>String()</em></strong></li></ol><p>String函数可以将任意类型的值转化成字符串，转换规则如下。</p><ol start="3"><li><strong><em>Boolean()</em></strong></li></ol><p>Boolean函数可以将任意类型的值转为布尔值。</p><h4 id="错误与异常处理"><a href="#错误与异常处理" class="headerlink" title="错误与异常处理"></a>错误与异常处理</h4><ul><li>错误对象</li></ul><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，<br>所有抛出的错误都是这个构造函数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var err = new Error(&apos;出错了&apos;);</span><br><span class="line">err.message // &quot;出错了&quot;</span><br></pre></td></tr></table></figure></p><ul><li><p>throw 语句<br>throw语句的作用是手动中断程序执行，抛出一个错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (x &lt;= 0) &#123;</span><br><span class="line">  throw new Error(&apos;x 必须为正数&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>try…catch 结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"> throw new Error(&apos;出错了!&apos;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line"> console.log(e.name + &quot;: &quot; + e.message);</span><br><span class="line"> console.log(e.stack);</span><br><span class="line">&#125;</span><br><span class="line">// Error: 出错了!</span><br><span class="line">//   at &lt;anonymous&gt;:3:9</span><br></pre></td></tr></table></figure></li><li><p>finally 代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function cleansUp() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&apos;出错了……&apos;);</span><br><span class="line">    console.log(&apos;此行不会执行&apos;);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    console.log(&apos;完成清理工作&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleansUp()</span><br></pre></td></tr></table></figure></li></ul><h3 id="console-对象与控制台"><a href="#console-对象与控制台" class="headerlink" title="console 对象与控制台"></a>console 对象与控制台</h3><ul><li>console 对象</li></ul><p>console对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出stdout和标准错误stderr，<br>可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p><p>在浏览器的开发者工具下通常可以找到控制台</p><p>按 F12 或者Control + Shift + j（PC）</p><ul><li>console 对象的静态方法</li></ul><p><strong><em>console.log()，console.info()</em></strong></p><p>console.log方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p><p>console.info是console.log方法的别名，用法完全一样。只不过console.info方法会在输出信息的前面，加上一个蓝色图标。</p><p>console.debug方法与console.log方法类似，会在控制台输出调试信息。但是，默认情况下，console.debug输出的信息不会显示，</p><ul><li>debugger 语句</li></ul><p>debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p><p>Chrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  if (i === 2) debugger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心技术-基础</title>
      <link href="/2019/02/23/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/02/23/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java核心技术-基础语法"><a href="#Java核心技术-基础语法" class="headerlink" title="Java核心技术-基础语法"></a>Java核心技术-基础语法</h1><blockquote><p>主要记录一些Java核心技术一书中的基础语法</p></blockquote><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>Arrays.toString()方法 （按字符串直接返回数组内容）</p><p>在遍历数组元素时可以使用for each，全部遍历数组元素。其中可以使用Arrays类的toString方法，用Arrays.toString(a),返回一个包含数组元素的字符串。</p></li><li><p>允许长度为0的数组</p><p>如果某方法需要返回一个数组，但碰巧结果为空，则可以使用长度为0<br>的数组 (new elementType[0]) </p><p><strong>注意：数组长度为0与null不同</strong></p></li></ul><ul><li><p>数组拷贝</p><p>在Java中允许对数组进行拷贝，即两个对象均引用内存中的同一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原数组smallPrimes=&#123;2,3,5,7,11,12&#125;</span></span><br><span class="line"><span class="keyword">int</span>[] luckNumbers = smallPrimes;</span><br><span class="line">luckNumbers[<span class="number">5</span>] = <span class="number">12</span>;</span><br><span class="line"><span class="comment">//数组拷贝还可以使用Arrays.copyOf();</span></span><br><span class="line"><span class="keyword">int</span>[] copiedLuckNumbers = Arrays.copyOf(luckNumber,<span class="number">2</span>*luckNumber.length);</span><br><span class="line"><span class="comment">//其中第一个参数为需要拷贝的原数组，第二个参数为拷贝后新数组的长度</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  如果数组元素的是数值类型，那么多余的元素将被赋值为0；如果元素时布尔类型将被赋值false。（都将会被赋值为Java中各个类型的默认值）。相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure></li><li><p>命令行参数</p><p>在Java中的main方法基本上都是带有一个String类型的数组作为main方法的参数，这说明main方法将接受到一个字符串数组，也就是目录参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (args .length == <span class="number">0</span> || args[<span class="number">0</span>].equals(<span class="string">"-h"</span>))&#123;</span><br><span class="line">         System.out.println(<span class="string">"HELLO,"</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"-g"</span>))&#123;</span><br><span class="line">         System.out.println(<span class="string">"Goodbye,"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;args.length;i++) &#123;</span><br><span class="line">         System.out.print(<span class="string">" "</span> + args[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.printn(<span class="string">"!"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真对命令行运行的方式：java Message -g cruel world</p><p><em>运行结果：Goodbye，cruel world！</em></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Markdown语言</title>
      <link href="/2019/01/24/%E5%88%9D%E8%AF%86Markdown%E8%AF%AD%E8%A8%80/"/>
      <url>/2019/01/24/%E5%88%9D%E8%AF%86Markdown%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Markdown语言"><a href="#初识Markdown语言" class="headerlink" title="初识Markdown语言"></a>初识Markdown语言</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于新搭建个人博客，所以也是第一次接触Markdown语言，在简单了解基本语法后，特此在这里将常用语法做一个梳理。</p><blockquote><p><a href="https://www.appinn.com/markdown/index.html" target="_blank" rel="noopener">主要参考：Markdown语法说明（简体中文版）</a></p></blockquote><p>Markdown的目标是实现“易读易写”。Markdown语言提倡的是让使用者只要关注与书写，而不是停下来调整格式。</p><p>总之，Markdown的语法全是由一些符号组成，这些符号经过精细的挑选，起作用一目了然。</p><p>Markdown语法的目标是：成为一种适用于网络书写的语言。说起和网络有关的语言，大多数人会想起HTML，其实Markdown与HTML还是有一些关系的。使用Markdown语言最终也是将文本信息显示到网页上（浏览器），所以Markdown最后会被转换为HTML语言。所以说Markdown语言可以很好的兼容HTML。</p><blockquote><p><strong>这也就是为什么个人搭建博客需要使用Markdown来书写</strong></p></blockquote><ul><li>多数情况下搭建个人博客需要使用到一些前端的框架，比如<em>Node.js</em>书写的个人博客相当于是静态网页（书写的内容也都将转换为.html）</li></ul><h2 id="基本常用语法"><a href="#基本常用语法" class="headerlink" title="基本常用语法"></a>基本常用语法</h2><hr><blockquote><h4 id="段落与换行"><a href="#段落与换行" class="headerlink" title="段落与换行"></a>段落与换行</h4><pre><code>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行，普通段落不该用空格或制表符来缩进。也就是说正常一次向后书写形成的就是一个段落。换行也就是相当于我们在使用文本编辑器编辑文本时敲击回车按键，在Markdown中允许在段内换行（相当于另起一段），只需要在上一行文本结尾处敲击两次空格再回车，便可另起一行（相当于回车换行）。</code></pre></blockquote><hr><blockquote><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><pre><code>Markdown中支持两种标题书写格式</code></pre></blockquote><pre><code>1、 This is an H1    =============    This is an H2    -------------使用任意数量的=和-来构建标题（=最高阶标题、-第二阶标题）2、 # 这是 H1    ## 这是 H2    ###### 这是 H6使用#来构建标题，#的数量代表标题为几阶（也可以使用「闭合」的样式书写，比如 ## 这是一个二阶标题 ##）</code></pre><hr><blockquote><h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h4><pre><code>Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。1、&gt; This is a blockquote with two paragraphs. Lorem ipsum        dolor sit amet,</code></pre><p>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>    正常书写<br>    2、&gt; This is the first level of quoting.</p><blockquote><p>This is nested blockquote.</p></blockquote><p>Back to the first level.<br>    允许嵌套<br>    3、&gt; ## 这是一个标题。</p><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><pre><code>引用区块内也可以嵌套其他Markdown语法</code></pre><hr><blockquote><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><pre><code>Markdown 支持有序列表和无序列表。</code></pre></blockquote><pre><code>无序列表使用*、+、—作为标记。1、*   Red   *   Green   *   Blue2、+   Red   +   Green   +   Blue3、-   Red   -   Green   -   Blue有序列表使用数字加英文句号   1.  Bird   2.  McHale   3.  Parish需要注意的是，在正常输入数字加英文句号时（例如：1998.）Markdown会认为是有序列表，所以在书写时在英文句号前加反斜杠（1998\.）</code></pre><hr><blockquote><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><pre><code>所谓代码区块是在书写程序的时候我们不希望限制于Markdown的显示格式，在代码区块中书写就和正常在文本编辑器中书写一样简单。</code></pre></blockquote><pre><code>使用Markdown构建代码区块也非常简单，只需要使用一个制表符（Tab）。</code></pre><hr><blockquote><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><pre><code>Markdown中使用三个以上的*、—、_、来构建分割线。1、***2、---</code></pre></blockquote><pre><code>3、___</code></pre><hr><blockquote><h4 id="强调字符"><a href="#强调字符" class="headerlink" title="强调字符"></a>强调字符</h4><pre><code>Markdown中使用*、_进行强调*斜体***加粗**_斜体_</code></pre></blockquote><pre><code>__加粗__</code></pre><hr><blockquote><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><pre><code>Markdown中允许使用表格，其格式如下：|列表1|列表2||:-:|:-:||a|b||c|d|其中：|:-|为左对齐|:-:|为居中</code></pre></blockquote><pre><code>|-:|为右对齐</code></pre><hr><blockquote><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><pre><code>Markdown 支持两种形式的链接语法：1、[连接的文字描述](http://example.com/)2、[连接的文字描述][id]   [id]:http://example.com/</code></pre></blockquote><pre><code>第二种方式中的[id]可以出现在文本的任意处。</code></pre><hr><blockquote><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><pre><code>Markdown作为一个文本编辑语言，直接插入图片是不可能的，所以 Markdown插入图片就参照了连接的做法（类似HTML中插入图片）。与连接相同，插入图片有两种格式：1、![图片信息](/path/to/imag.jpg)2、![图片信息][id]   [id]:/path/to/img.jpg</code></pre></blockquote><pre><code>值得注意的是，在插入图片时需要提供图片的URL，在书写个人博客的时候，如果存在少量图片，可以将其放在博客框架内，但是如果图片过多会导致博客加载变慢，所以推荐使用图床。</code></pre><hr><blockquote><p>以上便是Markdown常用的基本语法（日常书写博客是够了），如果还想显示更多的效果，可以使用HTML的相关语法功能（因为Markdown显示在网页上最终还是转换成静态页面）</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Eclipse下初识Maven</title>
      <link href="/2019/01/17/%E5%9C%A8Eclipse%E4%B8%8B%E5%88%9D%E8%AF%86Maven/"/>
      <url>/2019/01/17/%E5%9C%A8Eclipse%E4%B8%8B%E5%88%9D%E8%AF%86Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="在Eclipse下初识Maven"><a href="#在Eclipse下初识Maven" class="headerlink" title="在Eclipse下初识Maven"></a>在Eclipse下初识Maven</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在学习Java时，你可能就听说过Maven，现在让我们一起在Eclipse平台上了解一下Maven。</p><blockquote><p>主要参考：<a href="https://blog.csdn.net/u012052268/article/details/78916196#eclipse%E4%BD%BF%E7%94%A8maven%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">eclipse使用maven教程</a>、<br><a href="http://maven.apache.org/what-is-maven.html" target="_blank" rel="noopener">Maven官网介绍</a></p></blockquote><hr><h2 id="什么是Maven？"><a href="#什么是Maven？" class="headerlink" title="什么是Maven？"></a>什么是Maven？</h2><p>Maven是由开源组织Apache软件基金会开发与管理的、基于项目对象模型（POM）的软件项目管理软件。（官网：Maven can manage a project’s build, reporting and documentation from a central piece of information）</p><p>Maven的目标：</p><ul><li>使构建的过程变得简单</li><li>提供统一的构建系统</li><li>提供优质的项目信息</li><li>提供最佳时间开发指南</li><li>允许易懂的新功能的迁移</li></ul><p>简单的说Maven就是一个大型的管理项目的仓库，我们可以从这个大仓库里下载自己所需的依赖（项目所需的jar包），也可以将自己的开源项目上传至这个大仓库(类似GitHub)。这也是我们主要使用Maven的原因，可以不需要自己手动下载配置项目所需要的依赖（jar包），只需要通过Maven的pom.xml文件配置一些所需项目依赖的信息，Maven就会自动将这些依赖下载至项目本地。</p><hr><h2 id="Maven怎么通过配置文件寻找项目依赖？"><a href="#Maven怎么通过配置文件寻找项目依赖？" class="headerlink" title="Maven怎么通过配置文件寻找项目依赖？"></a>Maven怎么通过配置文件寻找项目依赖？</h2><p>通常情况下，我们使用Maven来构建Java/Java Web，这里以Java项目为例。</p><p>首先，我们想通过配置文件来下载项目所需的依赖，我们必须将这个项目创建为Maven项目，使用Maven创建的项目，相当于在普通项目外包裹了一层，这一层就是一个“管家”，里面的项目原来是什么，还是什么，不会因为外部包裹的这一层而受到影响。而外面的这层“管家”是受pom.xml文件的内容而控制的。</p><p>现在我们回到原来手动寻找项目依赖时的步骤。我们之前在构建项目的时候，在选用项目依赖时，通常都会考虑这个依赖的名称、版本之类的信息。同样，Maven在寻找项目依赖时也需要这些相关的信息，所以我们需要将这些信息写入pom.xml</p><blockquote><p><strong>Maven使用三个标签来确定一个项目依赖：</strong></p><ol><li>&lt;groupId&gt;&lt;groupId/&gt;</li><li>&lt;artifactId&gt;&lt;artifactId/&gt;</li><li>&lt;version&gt;&lt;version/&gt;</li></ol></blockquote><p> <img src="http://wx4.sinaimg.cn/large/006Dr5U1ly1fza1dovrdxj30v30baab9.jpg" alt="如下图："></p><p>加入上面的pom.xml文件属于A项目，那么A项目肯定是一个maven项目，通过上面这三个属性能够找到junit对应版本的jar包，那么junit项目肯定也是一个maven项目，junit的maven项目中的pom.xml文件就会有三个标识符，比如像下图这样，然后别的maven项目就能通过这三个属性来找到junit项目的jar包了。所以，在每个创建的maven项目时都会要求写上这三个属性值的。<br><img src="http://wx3.sinaimg.cn/large/006Dr5U1ly1fza1jcjw0wj30ql038aa9.jpg" alt=""></p><hr><h2 id="下载、安装与配置Maven"><a href="#下载、安装与配置Maven" class="headerlink" title="下载、安装与配置Maven"></a>下载、安装与配置Maven</h2><blockquote><p>下载Maven <a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p></blockquote><p>通过官网，下载最新的Maven<br><img src="http://wx2.sinaimg.cn/large/006Dr5U1ly1fzal85be09j318b0b00ui.jpg" alt=""></p><blockquote><p>安装Maven</p></blockquote><p>将下载好的Maven压缩包解压，你就会发现其实它和Tomcat很像，就是一个文件夹，不需要安装，只需要解压到你指定的目录下。（Maven是需要Java环境的，请提前装好JDK）<br><img src="http://wx2.sinaimg.cn/mw690/006Dr5U1ly1fzaldrty6dj30sf08k3z2.jpg" alt=""></p><blockquote><p>配置Maven</p></blockquote><p>观察Maven文件夹下的文件，我们不难发现，conf文件便是存放配置文件的地方。打开后我们会发现setting.xml文件，这个文件便是配置Maven的设置文件，打开后如图修改对应的内容。<br><img src="http://wx3.sinaimg.cn/large/006Dr5U1ly1fzalm6nx0ej30s105s3z3.jpg" alt=""></p><p><strong>(注意：&lt;localRepository&gt;标签最初是在其上面的注释内，注意将其移处注释后在修改)</strong></p><p>接下来，如果你以后想通过git、powershell等Terminal工具使用Maven，就需要配置环境变量，只使用IDE的可跳过。</p><p>Maven环境变量的配置与JDK相同，首先是新建系统变量MAVEN_HOME，将解压的Maven文件夹的目录填入。在新添加用户变量Path，将%MAVEN_HOME\bin%新建添加。</p><p>测试环境变量是否配置完成，在Terminal工具中输入mvn -version能够显示如下内容，证明配置成功。<br><img src="http://wx4.sinaimg.cn/large/006Dr5U1ly1fzam3fa4suj30rm05hmxj.jpg" alt=""></p><blockquote><p>在Eclipse中安装与配置</p></blockquote><p>在Eclipse中可以使用Eclipse官网提供的插件进行安装，也可以使用自己下载安装的Maven。（这里的操作与Tomcat相同）这里推荐使用外部下载安装的Maven。</p><p>首先打开Eclipse，打开窗口 -&gt; 首选项，如图添加：<br><img src="http://wx4.sinaimg.cn/large/006Dr5U1ly1fzamlczgvdj30pb0g5gmm.jpg" alt=""><br><img src="http://wx1.sinaimg.cn/large/006Dr5U1ly1fzamldl9blj30pb0g5dgx.jpg" alt=""></p><p>注意设置Local Repository，这个是Maven的本地仓位置，也就是之前在setting.xml中添加的那一条地址，在setting.xml中添加后者这里便不能修改。</p><hr><h2 id="在Eclipse中使用Maven"><a href="#在Eclipse中使用Maven" class="headerlink" title="在Eclipse中使用Maven"></a>在Eclipse中使用Maven</h2><p>打开Eclipse，新建一个Maven项目<br><img src="http://wx2.sinaimg.cn/large/006Dr5U1ly1fzan1wss95j30le0hzq3s.jpg" alt=""></p><p>其中，quickstart为一般的Java项目，webapp为Java Web项目。<br><img src="http://wx2.sinaimg.cn/large/006Dr5U1ly1fzan1x445dj30le0hz0t7.jpg" alt=""></p><p>正如前面所说，我们在这里也需要提供GroupId、ArtifactId、Version。</p><p><img src="http://wx2.sinaimg.cn/large/006Dr5U1ly1fzan76v0zfj307z0cx74m.jpg" alt=""><br>以上是Maven的文件组成结构：</p><ul><li>pom.xml：用于定义或者添加jar包的依赖</li><li>src-main：用于存放java源文件</li><li>src-test：用于存放测试用例。</li><li>target：用来生成对应的class文件或发布的jar包。</li></ul><p>现在我们可以将所需要的项目依赖信息填入pom.xml中，在pom.xml页面右键，选择Run AS -&gt; Maven Bulid,即可通过Maven构建项目。</p><p>至此，我们通过Eclipse了解了Mave的安装与文件组成结构。对于经常使用Linux或者Terminal工具的用户，也可以使用命令行操作Maven。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
